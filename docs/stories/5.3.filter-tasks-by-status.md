# Story 5.3: Filter Tasks by Status

**Epic:** EPIC-5 - Dashboard & Tracking
**Story ID:** US-5.3
**Priority:** Critical (P0)
**Status:** Draft

---

## Story

**As a** user,
**I want** to filter tasks by paid/unpaid status,
**so that** I can focus on specific types of tasks

---

## Acceptance Criteria

1. Filter controls visible on dashboard (tabs, dropdown, or buttons)
2. Filter options:
   - "All" - Show all tasks (UNPAID + PAID)
   - "Unpaid" - Show only UNPAID tasks (default)
   - "Paid" - Show only PAID tasks
3. Active filter visually indicated (highlighted tab/button)
4. Task list updates instantly when filter changed
5. Filter state persists across page refreshes (localStorage or URL param)
6. Task count shown in filter label: "Unpaid (5)"
7. Empty states for each filter:
   - All: "No tasks yet"
   - Unpaid: "No unpaid bills"
   - Paid: "No completed payments"

---

## Tasks / Subtasks

- [ ] Create filter UI component (AC: 1, 2)
  - [ ] Create `components/dashboard/TaskFilter.tsx`
  - [ ] Build tab/button UI for 3 filter options
  - [ ] Use shadcn/ui Tabs component
  - [ ] Make component a client component ('use client')
  - [ ] Apply consistent styling

- [ ] Implement filter state management (AC: 3, 4)
  - [ ] Create React state for active filter
  - [ ] Handle filter change events
  - [ ] Update active filter indicator
  - [ ] Trigger task list re-query on filter change
  - [ ] Default to "Unpaid" filter

- [ ] Add task count to filter labels (AC: 6)
  - [ ] Query count for each status
  - [ ] Display count in parentheses
  - [ ] Update counts dynamically
  - [ ] Handle loading state for counts

- [ ] Implement filter persistence (AC: 5)
  - [ ] Option 1: Use URL search params (?status=unpaid)
  - [ ] Option 2: Use localStorage
  - [ ] Restore filter on page load
  - [ ] Sync filter across browser tabs (optional)

- [ ] Update task query with filter (AC: 4)
  - [ ] Modify Prisma query with dynamic where clause
  - [ ] Handle "all" filter (no status filter)
  - [ ] Handle "unpaid" filter (status: UNPAID)
  - [ ] Handle "paid" filter (status: PAID)
  - [ ] Maintain sorting and pagination

- [ ] Add empty states for each filter (AC: 7)
  - [ ] Create EmptyState component
  - [ ] Show different messages per filter
  - [ ] Add CTAs when appropriate
  - [ ] Apply consistent styling

- [ ] Ensure instant UI updates (AC: 4)
  - [ ] Use client component for interactivity
  - [ ] Consider React Server Actions for data fetching
  - [ ] Implement optimistic UI updates (optional)
  - [ ] Show loading skeleton during fetch

---

## Dev Notes

### Technical Context

**Tech Stack:**
- Frontend: Next.js Client Components (for interactivity)
- State: React useState + URL search params or localStorage
- UI: shadcn/ui Tabs component
- Database: Prisma with dynamic queries

**Integration Points:**
- US-5.1, US-5.2: Dashboard task display
- Epic 4: Task history integration
- All task-related components

**Key Implementation Details:**

**TaskFilter Component (`components/dashboard/TaskFilter.tsx`):**
```typescript
'use client';

import { Tabs, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { useRouter, useSearchParams } from 'next/navigation';

interface TaskFilterProps {
  counts: {
    all: number;
    unpaid: number;
    paid: number;
  };
}

export function TaskFilter({ counts }: TaskFilterProps) {
  const router = useRouter();
  const searchParams = useSearchParams();
  const activeFilter = searchParams.get('status') || 'unpaid';

  const handleFilterChange = (value: string) => {
    const params = new URLSearchParams(searchParams);
    params.set('status', value);
    router.push(`?${params.toString()}`);
  };

  return (
    <Tabs value={activeFilter} onValueChange={handleFilterChange}>
      <TabsList>
        <TabsTrigger value="all">
          All ({counts.all})
        </TabsTrigger>
        <TabsTrigger value="unpaid">
          Unpaid ({counts.unpaid})
        </TabsTrigger>
        <TabsTrigger value="paid">
          Paid ({counts.paid})
        </TabsTrigger>
      </TabsList>
    </Tabs>
  );
}
```

**Alternative: LocalStorage Persistence:**
```typescript
'use client';

import { useState, useEffect } from 'react';
import { Tabs, TabsList, TabsTrigger } from '@/components/ui/tabs';

type FilterValue = 'all' | 'unpaid' | 'paid';

interface TaskFilterProps {
  counts: { all: number; unpaid: number; paid: number };
  onFilterChange: (filter: FilterValue) => void;
}

export function TaskFilter({ counts, onFilterChange }: TaskFilterProps) {
  const [activeFilter, setActiveFilter] = useState<FilterValue>('unpaid');

  // Restore filter from localStorage on mount
  useEffect(() => {
    const saved = localStorage.getItem('taskFilter') as FilterValue;
    if (saved) {
      setActiveFilter(saved);
      onFilterChange(saved);
    }
  }, []);

  const handleFilterChange = (value: FilterValue) => {
    setActiveFilter(value);
    localStorage.setItem('taskFilter', value);
    onFilterChange(value);
  };

  return (
    <Tabs value={activeFilter} onValueChange={handleFilterChange}>
      <TabsList>
        <TabsTrigger value="all">All ({counts.all})</TabsTrigger>
        <TabsTrigger value="unpaid">Unpaid ({counts.unpaid})</TabsTrigger>
        <TabsTrigger value="paid">Paid ({counts.paid})</TabsTrigger>
      </TabsList>
    </Tabs>
  );
}
```

**Dashboard Page with Filter (`app/dashboard/page.tsx`):**
```typescript
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import { TaskFilter } from '@/components/dashboard/TaskFilter';
import { TaskList } from '@/components/dashboard/TaskList';

interface DashboardPageProps {
  searchParams: { status?: string };
}

export default async function DashboardPage({ searchParams }: DashboardPageProps) {
  const session = await getServerSession(authOptions);
  if (!session) redirect('/login');

  const status = searchParams.status || 'unpaid';

  // Build dynamic where clause
  const whereClause = {
    userId: session.user.id,
    ...(status !== 'all' && { status: status.toUpperCase() })
  };

  // Fetch tasks with filter
  const tasks = await prisma.task.findMany({
    where: whereClause,
    include: { bill: true },
    orderBy: { dueDate: 'asc' }
  });

  // Fetch counts for filter labels
  const counts = {
    all: await prisma.task.count({ where: { userId: session.user.id } }),
    unpaid: await prisma.task.count({ where: { userId: session.user.id, status: 'UNPAID' } }),
    paid: await prisma.task.count({ where: { userId: session.user.id, status: 'PAID' } })
  };

  return (
    <div>
      <h1>Dashboard</h1>
      <TaskFilter counts={counts} />
      <TaskList tasks={tasks} filter={status} />
    </div>
  );
}
```

**TaskList Component with Empty States:**
```typescript
import { TaskCard } from '@/components/tasks/TaskCard';
import type { Task, Bill } from '@prisma/client';

interface TaskListProps {
  tasks: (Task & { bill: Bill })[];
  filter: string;
}

export function TaskList({ tasks, filter }: TaskListProps) {
  if (tasks.length === 0) {
    return <EmptyState filter={filter} />;
  }

  return (
    <div className="space-y-3">
      {tasks.map(task => (
        <TaskCard key={task.id} task={task} />
      ))}
    </div>
  );
}

function EmptyState({ filter }: { filter: string }) {
  const messages = {
    all: {
      title: 'No tasks yet',
      description: 'Add your first bill to get started',
      cta: 'Add Bill'
    },
    unpaid: {
      title: 'No unpaid bills',
      description: 'All caught up! No pending payments.',
      cta: null
    },
    paid: {
      title: 'No completed payments',
      description: 'Paid bills will appear here',
      cta: null
    }
  };

  const message = messages[filter as keyof typeof messages] || messages.all;

  return (
    <div className="text-center py-12">
      <h3 className="text-lg font-semibold text-muted-foreground">
        {message.title}
      </h3>
      <p className="text-sm text-muted-foreground mt-2">
        {message.description}
      </p>
      {message.cta && (
        <a href="/bills/new" className="btn btn-primary mt-4">
          {message.cta}
        </a>
      )}
    </div>
  );
}
```

**Dynamic Prisma Query:**
```typescript
// Build where clause based on filter
const getWhereClause = (userId: string, filter: string) => {
  const base = { userId };

  if (filter === 'all') {
    return base;
  }

  if (filter === 'unpaid') {
    return { ...base, status: 'UNPAID' };
  }

  if (filter === 'paid') {
    return { ...base, status: 'PAID' };
  }

  return base;
};

const tasks = await prisma.task.findMany({
  where: getWhereClause(session.user.id, status),
  include: { bill: true },
  orderBy: { dueDate: 'asc' }
});
```

**URL Search Params Approach (Recommended):**
- Pros: Shareable URLs, browser back/forward support, SEO-friendly
- Cons: Slightly more complex client-side routing

**LocalStorage Approach:**
- Pros: Simpler implementation, no URL pollution
- Cons: Not shareable, no back/forward support

**Recommendation: Use URL search params** for better UX and browser integration.

**Performance Optimization:**
- Cache counts using React Server Components
- Use Prisma count queries efficiently
- Consider debouncing filter changes if using search input
- Use skeleton loading states during transitions

### Dependencies

**Upstream Dependencies:**
- US-5.1, US-5.2: Task display components
- Epic 2: Task creation with status field

**Downstream Dependencies:**
- Epic 4 (Task History): May use similar filtering

### Testing

**Test Location:** `__tests__/components/dashboard/TaskFilter.test.tsx` and `__tests__/app/dashboard/page.test.tsx`

**Testing Standards:**
- Unit tests for TaskFilter component
- Integration tests for filtered queries
- E2E test for filter interactions
- Test persistence (URL params or localStorage)
- Test empty states

**Testing Frameworks:**
- Jest for unit tests
- React Testing Library for component tests
- Playwright for E2E tests
- Mock Prisma client for database queries

**Specific Requirements:**
- Test TaskFilter renders all 3 tabs
- Test TaskFilter shows correct counts
- Test clicking "All" updates active filter
- Test clicking "Unpaid" updates active filter
- Test clicking "Paid" updates active filter
- Test active filter visually highlighted
- Test task list updates when filter changes
- Test URL params update when filter changes
- Test filter restored from URL on page load
- Test localStorage persistence (if used)
- Test empty state for "All" filter
- Test empty state for "Unpaid" filter
- Test empty state for "Paid" filter
- Test Prisma query with all filter (no status filter)
- Test Prisma query with unpaid filter
- Test Prisma query with paid filter
- Test counts calculated correctly
- Mock getServerSession for authenticated tests
- Mock Prisma with filtered task data

**Test Scenarios:**
1. **Default filter**: Page loads with "Unpaid" filter active
2. **Switch to "All"**: Shows all tasks (paid + unpaid)
3. **Switch to "Paid"**: Shows only paid tasks
4. **Empty unpaid list**: Shows "No unpaid bills" message
5. **Empty paid list**: Shows "No completed payments" message
6. **Empty all list**: Shows "No tasks yet" with CTA
7. **URL persistence**: Reload page with ?status=paid → filter restored
8. **Count updates**: Mark task as paid → unpaid count decreases
9. **Filter with overdue**: Overdue tasks respect filter
10. **Shareable URL**: Copy URL with filter → paste in new tab → filter applied

**Mock Data Example:**
```typescript
const mockTasks = {
  unpaid: [
    { id: '1', status: 'UNPAID', dueDate: addDays(new Date(), 3), bill: {...} },
    { id: '2', status: 'UNPAID', dueDate: addDays(new Date(), 5), bill: {...} }
  ],
  paid: [
    { id: '3', status: 'PAID', dueDate: subDays(new Date(), 2), bill: {...} }
  ]
};

const mockCounts = {
  all: 3,
  unpaid: 2,
  paid: 1
};
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-03 | 1.0 | Initial story creation from Epic 5 | Sarah (PO) |

---

## Dev Agent Record

### Agent Model Used

_To be populated by dev agent_

### Debug Log References

_To be populated by dev agent_

### Completion Notes List

_To be populated by dev agent_

### File List

_To be populated by dev agent_

---

## QA Results

_To be populated by QA agent_
