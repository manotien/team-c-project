# US-3.1: LINE Notification on Bill Creation

**Story ID:** US-3.1
**Epic:** [Epic 3: Notifications](epic-3-notifications.md)
**Priority:** High (P1)
**Story Points:** 5
**Status:** Ready for Development

---

## User Story

**As a** user
**I want to** receive a LINE notification when I add a bill
**So that** I get instant confirmation and can track it in my LINE chat

---

## Acceptance Criteria

- [ ] LINE notification sent immediately after bill + task creation
- [ ] Notification contains:
  - [ ] Bill vendor name
  - [ ] Bill amount (‡∏ø1,500.00)
  - [ ] Due date (readable format)
  - [ ] Bill type icon (‚ö°üíßüåêüöóüè†)
  - [ ] Link to view bill in app (deep link to task detail)
- [ ] Notification sent via LINE Messaging API (Official Account)
- [ ] User's LINE ID retrieved from authenticated session
- [ ] Notification record created in database (type: BILL_CREATED, status: SENT)
- [ ] Graceful handling if LINE API fails (logged but doesn't block bill creation)
- [ ] Notification delivery confirmation logged

---

## Technical Implementation

### Database Schema
**File:** `prisma/schema.prisma`

```prisma
model Notification {
  id        String    @id @default(uuid())
  userId    String
  taskId    String
  type      String    // 'BILL_CREATED' | 'DUE_SOON' | 'DUE_TODAY'
  status    String    // 'PENDING' | 'SENT' | 'FAILED' | 'READ'
  message   String
  sentAt    DateTime?
  readAt    DateTime?
  metadata  Json      @default("{}")
  createdAt DateTime  @default(now())

  user      User      @relation(fields: [userId], references: [id])
  task      Task      @relation(fields: [taskId], references: [id])

  @@index([userId])
  @@index([status])
}
```

### Backend Implementation

**File:** `lib/services/lineNotificationService.ts`

```typescript
import axios from 'axios';
import { prisma } from '@/lib/prisma';

const LINE_CHANNEL_ACCESS_TOKEN = process.env.LINE_CHANNEL_ACCESS_TOKEN!;
const LINE_MESSAGING_API_URL = 'https://api.line.me/v2/bot/message/push';
const LIFF_ID = process.env.NEXT_PUBLIC_LIFF_ID!;

interface Bill {
  id: string;
  vendor: string;
  amount: number;
  dueDate: Date;
  type: string;
}

interface Task {
  id: string;
  billId: string;
}

export async function sendBillCreatedNotification(
  userId: string,
  lineUserId: string,
  bill: Bill,
  task: Task
) {
  try {
    // Create notification record
    const notification = await prisma.notification.create({
      data: {
        userId,
        taskId: task.id,
        type: 'BILL_CREATED',
        status: 'PENDING',
        message: `Bill added: ${bill.vendor} - ‡∏ø${bill.amount.toFixed(2)}`,
        metadata: {
          billId: bill.id,
          taskId: task.id,
        },
      },
    });

    // Format message
    const message = createBillCreatedFlexMessage(bill, task);

    // Send to LINE
    await axios.post(
      LINE_MESSAGING_API_URL,
      {
        to: lineUserId,
        messages: [message],
      },
      {
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${LINE_CHANNEL_ACCESS_TOKEN}`,
        },
      }
    );

    // Update notification status
    await prisma.notification.update({
      where: { id: notification.id },
      data: {
        status: 'SENT',
        sentAt: new Date(),
      },
    });

    console.log(`‚úÖ LINE notification sent for task ${task.id}`);
    return { success: true, notificationId: notification.id };
  } catch (error) {
    console.error('‚ùå Failed to send LINE notification:', error);

    // Log failure but don't throw (non-blocking)
    if (notification) {
      await prisma.notification.update({
        where: { id: notification.id },
        data: { status: 'FAILED' },
      });
    }

    return { success: false, error };
  }
}

function createBillCreatedFlexMessage(bill: Bill, task: Task) {
  const deepLink = `https://liff.line.me/${LIFF_ID}?path=/tasks/${task.id}`;
  const billTypeIcon = getBillTypeIcon(bill.type);
  const formattedAmount = `‡∏ø${bill.amount.toLocaleString('th-TH', {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  })}`;
  const formattedDate = new Date(bill.dueDate).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
  });

  return {
    type: 'flex',
    altText: `Bill added: ${bill.vendor}`,
    contents: {
      type: 'bubble',
      body: {
        type: 'box',
        layout: 'vertical',
        contents: [
          {
            type: 'text',
            text: '‚úÖ Bill Added',
            weight: 'bold',
            size: 'xl',
            color: '#1DB446',
          },
          {
            type: 'box',
            layout: 'vertical',
            margin: 'lg',
            spacing: 'sm',
            contents: [
              {
                type: 'box',
                layout: 'baseline',
                spacing: 'sm',
                contents: [
                  {
                    type: 'text',
                    text: billTypeIcon,
                    size: 'xl',
                    flex: 0,
                  },
                  {
                    type: 'text',
                    text: bill.vendor,
                    weight: 'bold',
                    size: 'lg',
                    flex: 1,
                  },
                ],
              },
              {
                type: 'box',
                layout: 'baseline',
                spacing: 'sm',
                contents: [
                  {
                    type: 'text',
                    text: 'Amount:',
                    color: '#aaaaaa',
                    size: 'sm',
                    flex: 1,
                  },
                  {
                    type: 'text',
                    text: formattedAmount,
                    weight: 'bold',
                    size: 'md',
                    flex: 2,
                    align: 'end',
                  },
                ],
              },
              {
                type: 'box',
                layout: 'baseline',
                spacing: 'sm',
                contents: [
                  {
                    type: 'text',
                    text: 'Due Date:',
                    color: '#aaaaaa',
                    size: 'sm',
                    flex: 1,
                  },
                  {
                    type: 'text',
                    text: formattedDate,
                    size: 'sm',
                    flex: 2,
                    align: 'end',
                  },
                ],
              },
            ],
          },
        ],
      },
      footer: {
        type: 'box',
        layout: 'vertical',
        spacing: 'sm',
        contents: [
          {
            type: 'button',
            style: 'primary',
            action: {
              type: 'uri',
              label: 'View Task',
              uri: deepLink,
            },
          },
        ],
      },
    },
  };
}

function getBillTypeIcon(type: string): string {
  const icons: Record<string, string> = {
    electricity: '‚ö°',
    water: 'üíß',
    internet: 'üåê',
    car: 'üöó',
    rent: 'üè†',
  };
  return icons[type] || 'üìÑ';
}
```

**File:** `app/api/bills/route.ts` (Updated)

```typescript
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import { sendBillCreatedNotification } from '@/lib/services/lineNotificationService';

export async function POST(req: Request) {
  const session = await getServerSession(authOptions);

  if (!session?.user?.id) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const data = await req.json();

  try {
    // Create bill and task in transaction
    const result = await prisma.$transaction(async (tx) => {
      const bill = await tx.bill.create({
        data: {
          ...data,
          userId: session.user.id,
        },
      });

      const task = await tx.task.create({
        data: {
          billId: bill.id,
          userId: session.user.id,
          title: `Pay ${bill.vendor} bill`,
          status: 'UNPAID',
          dueDate: bill.dueDate,
        },
      });

      return { bill, task };
    });

    // Send LINE notification (non-blocking)
    // Don't await - fire and forget to avoid blocking response
    if (session.user.lineUserId) {
      sendBillCreatedNotification(
        session.user.id,
        session.user.lineUserId,
        result.bill,
        result.task
      ).catch((error) => {
        console.error('Background notification failed:', error);
      });
    }

    return NextResponse.json({
      message: 'Bill and task created',
      ...result,
    });
  } catch (error) {
    console.error('Error creating bill and task:', error);
    return NextResponse.json(
      { error: 'Failed to create bill and task' },
      { status: 500 }
    );
  }
}
```

**File:** `.env.local` (Environment Variables)

```bash
# LINE Messaging API
LINE_CHANNEL_ACCESS_TOKEN=your_channel_access_token
LINE_CHANNEL_SECRET=your_channel_secret

# LIFF App
NEXT_PUBLIC_LIFF_ID=your_liff_id
```

---

## Technical Notes

- **Non-blocking:** Notification sending doesn't block bill creation (fire and forget)
- **LINE Messaging API:** Uses push message endpoint with channel access token
- **Flex Message:** Rich message format with button for deep linking
- **Deep Link:** LIFF URL navigates to task detail page in app
- **Error Handling:** Failures logged but don't affect bill creation success
- **Database Record:** All notifications logged for audit trail

---

## Testing Requirements

### Unit Tests
- [ ] Test `sendBillCreatedNotification` creates notification record
- [ ] Test Flex message format is valid
- [ ] Test LINE API request payload structure
- [ ] Test error handling when LINE API fails
- [ ] Test notification status updates (PENDING ‚Üí SENT/FAILED)

### Integration Tests
- [ ] Test POST /api/bills triggers notification
- [ ] Test notification record created in database
- [ ] Test LINE API called with correct parameters
- [ ] Test bill creation succeeds even if notification fails

### E2E Tests
- [ ] Create bill ‚Üí receive LINE notification on mobile
- [ ] Click "View Task" button ‚Üí navigate to task detail page
- [ ] Verify notification contains correct bill data

---

## Dependencies

**Upstream:**
- Epic 2 US-2.1: Bill and task creation
- Epic 9 (Login & Auth): User's LINE ID from auth session

**Downstream:**
- Epic 4 (Task Actions): Deep link target (task detail page)
- Epic 3 US-3.3: Notification record displayed in notification center

**External:**
- LINE Official Account setup
- LINE Messaging API credentials
- LIFF app configured

---

## Definition of Done

- [ ] All acceptance criteria met
- [ ] LINE Messaging API integration implemented
- [ ] Notification service created and tested
- [ ] Database schema updated with Notification model
- [ ] Bill creation triggers notification
- [ ] Flex message format validated
- [ ] Deep link navigation working
- [ ] Error handling for API failures
- [ ] Non-blocking notification sending
- [ ] Unit tests passing
- [ ] E2E test passing
- [ ] Code reviewed and merged

---

## Environment Setup

### LINE Official Account Setup
1. Create LINE Official Account at https://developers.line.biz/
2. Create Messaging API channel
3. Get Channel Access Token
4. Get Channel Secret
5. Configure webhook URL (for future message handling)

### LIFF App Setup
1. Create LIFF app in LINE Developers Console
2. Set endpoint URL to your Next.js app
3. Get LIFF ID
4. Configure scope: `openid`, `profile`

---

## Risk Assessment

**Primary Risk:** LINE Messaging API rate limits or delivery failures
**Mitigation:**
- Non-blocking implementation (doesn't affect bill creation)
- Retry logic in future enhancement
- Notification record tracks failures for debugging

**Secondary Risk:** User's LINE ID not available in session
**Mitigation:**
- Check for LINE ID before sending
- Skip notification if not available
- Log warning for debugging

---

## Notes

- **P1 Priority:** Enhances UX but not critical path for MVP
- **Fire and Forget:** Notification failures don't block bill creation
- **Audit Trail:** All notifications logged in database
- **Rich Format:** Flex Message provides better UX than plain text
- **Deep Linking:** LIFF enables seamless navigation from LINE to app
