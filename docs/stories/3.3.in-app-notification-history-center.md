# US-3.3: In-App Notification History Center

**Story ID:** US-3.3
**Epic:** [Epic 3: Notifications](epic-3-notifications.md)
**Priority:** High (P1)
**Story Points:** 5
**Status:** Ready for Development

---

## User Story

**As a** user
**I want to** see in-app notifications and a history center
**So that** I can review past notifications and track bill activity

---

## Acceptance Criteria

- [ ] Notification bell icon in app header/navigation
- [ ] Badge shows count of unread notifications
- [ ] Click bell opens notification center (dropdown or page)
- [ ] Notification center displays:
  - [ ] List of all notifications (newest first)
  - [ ] Each notification shows: type icon, message, timestamp, read/unread status
  - [ ] Unread notifications highlighted
  - [ ] Click notification marks as read and navigates to related task
- [ ] "Mark all as read" button
- [ ] Pagination or infinite scroll for large notification lists
- [ ] Empty state: "No notifications yet"
- [ ] Real-time update when new notification received (optional for MVP)

---

## Technical Implementation

### Backend API

**File:** `app/api/notifications/route.ts`

```typescript
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

export async function GET(req: Request) {
  const session = await getServerSession(authOptions);

  if (!session?.user?.id) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { searchParams } = new URL(req.url);
  const page = parseInt(searchParams.get('page') || '1');
  const limit = parseInt(searchParams.get('limit') || '20');
  const skip = (page - 1) * limit;

  const [notifications, total, unreadCount] = await Promise.all([
    prisma.notification.findMany({
      where: { userId: session.user.id },
      include: {
        task: {
          include: {
            bill: true,
          },
        },
      },
      orderBy: { createdAt: 'desc' },
      skip,
      take: limit,
    }),
    prisma.notification.count({
      where: { userId: session.user.id },
    }),
    prisma.notification.count({
      where: {
        userId: session.user.id,
        readAt: null,
      },
    }),
  ]);

  return NextResponse.json({
    notifications,
    pagination: {
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
    },
    unreadCount,
  });
}
```

**File:** `app/api/notifications/[id]/read/route.ts`

```typescript
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

export async function PATCH(
  req: Request,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);

  if (!session?.user?.id) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const notification = await prisma.notification.update({
    where: {
      id: params.id,
      userId: session.user.id, // Ensure user owns notification
    },
    data: {
      status: 'READ',
      readAt: new Date(),
    },
  });

  return NextResponse.json(notification);
}
```

**File:** `app/api/notifications/mark-all-read/route.ts`

```typescript
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

export async function PATCH(req: Request) {
  const session = await getServerSession(authOptions);

  if (!session?.user?.id) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const result = await prisma.notification.updateMany({
    where: {
      userId: session.user.id,
      readAt: null,
    },
    data: {
      status: 'READ',
      readAt: new Date(),
    },
  });

  return NextResponse.json({
    message: 'All notifications marked as read',
    count: result.count,
  });
}
```

### Frontend Components

**File:** `components/notifications/NotificationBell.tsx`

```typescript
'use client';

import { useState, useEffect } from 'react';
import { BellIcon } from '@heroicons/react/24/outline';
import NotificationDropdown from './NotificationDropdown';

export default function NotificationBell() {
  const [isOpen, setIsOpen] = useState(false);
  const [unreadCount, setUnreadCount] = useState(0);

  useEffect(() => {
    fetchUnreadCount();
    // Poll for new notifications every 30 seconds (optional)
    const interval = setInterval(fetchUnreadCount, 30000);
    return () => clearInterval(interval);
  }, []);

  async function fetchUnreadCount() {
    const res = await fetch('/api/notifications?limit=0');
    const data = await res.json();
    setUnreadCount(data.unreadCount);
  }

  return (
    <div className="relative">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="relative p-2 hover:bg-gray-100 rounded-full"
      >
        <BellIcon className="h-6 w-6 text-gray-700" />
        {unreadCount > 0 && (
          <span className="absolute top-0 right-0 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">
            {unreadCount > 9 ? '9+' : unreadCount}
          </span>
        )}
      </button>

      {isOpen && (
        <NotificationDropdown
          onClose={() => setIsOpen(false)}
          onCountChange={setUnreadCount}
        />
      )}
    </div>
  );
}
```

**File:** `components/notifications/NotificationDropdown.tsx`

```typescript
'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import NotificationItem from './NotificationItem';

interface NotificationDropdownProps {
  onClose: () => void;
  onCountChange: (count: number) => void;
}

export default function NotificationDropdown({
  onClose,
  onCountChange,
}: NotificationDropdownProps) {
  const router = useRouter();
  const [notifications, setNotifications] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchNotifications();
  }, []);

  async function fetchNotifications() {
    setLoading(true);
    const res = await fetch('/api/notifications?limit=10');
    const data = await res.json();
    setNotifications(data.notifications);
    setLoading(false);
  }

  async function handleNotificationClick(notification: any) {
    // Mark as read
    if (!notification.readAt) {
      await fetch(`/api/notifications/${notification.id}/read`, {
        method: 'PATCH',
      });
      onCountChange((prev) => Math.max(0, prev - 1));
    }

    // Navigate to task
    router.push(`/tasks/${notification.taskId}`);
    onClose();
  }

  async function handleMarkAllRead() {
    await fetch('/api/notifications/mark-all-read', {
      method: 'PATCH',
    });
    onCountChange(0);
    fetchNotifications();
  }

  return (
    <div className="absolute right-0 mt-2 w-96 bg-white rounded-lg shadow-lg border border-gray-200 z-50">
      {/* Header */}
      <div className="flex items-center justify-between p-4 border-b">
        <h3 className="font-semibold text-lg">Notifications</h3>
        <button
          onClick={handleMarkAllRead}
          className="text-sm text-blue-600 hover:text-blue-700"
        >
          Mark all read
        </button>
      </div>

      {/* Notification List */}
      <div className="max-h-96 overflow-y-auto">
        {loading ? (
          <div className="p-8 text-center text-gray-500">Loading...</div>
        ) : notifications.length === 0 ? (
          <div className="p-8 text-center text-gray-500">
            No notifications yet
          </div>
        ) : (
          notifications.map((notification) => (
            <NotificationItem
              key={notification.id}
              notification={notification}
              onClick={() => handleNotificationClick(notification)}
            />
          ))
        )}
      </div>

      {/* Footer */}
      {notifications.length > 0 && (
        <div className="p-3 border-t text-center">
          <button
            onClick={() => {
              router.push('/notifications');
              onClose();
            }}
            className="text-sm text-blue-600 hover:text-blue-700"
          >
            View all notifications
          </button>
        </div>
      )}
    </div>
  );
}
```

**File:** `components/notifications/NotificationItem.tsx`

```typescript
'use client';

import { formatDistanceToNow } from 'date-fns';

interface NotificationItemProps {
  notification: any;
  onClick: () => void;
}

export default function NotificationItem({
  notification,
  onClick,
}: NotificationItemProps) {
  const isUnread = !notification.readAt;
  const icon = getNotificationIcon(notification.type);

  return (
    <div
      onClick={onClick}
      className={`p-4 border-b hover:bg-gray-50 cursor-pointer ${
        isUnread ? 'bg-blue-50' : ''
      }`}
    >
      <div className="flex items-start gap-3">
        {/* Icon */}
        <div className="text-2xl">{icon}</div>

        {/* Content */}
        <div className="flex-1 min-w-0">
          <p className={`text-sm ${isUnread ? 'font-semibold' : ''}`}>
            {notification.message}
          </p>
          <p className="text-xs text-gray-500 mt-1">
            {formatDistanceToNow(new Date(notification.createdAt), {
              addSuffix: true,
            })}
          </p>
        </div>

        {/* Unread indicator */}
        {isUnread && (
          <div className="w-2 h-2 bg-blue-500 rounded-full mt-2" />
        )}
      </div>
    </div>
  );
}

function getNotificationIcon(type: string): string {
  const icons: Record<string, string> = {
    BILL_CREATED: 'âœ…',
    DUE_SOON: 'â°',
    DUE_TODAY: 'âš ï¸',
  };
  return icons[type] || 'ğŸ“¬';
}
```

**File:** `app/(dashboard)/notifications/page.tsx` (Full Page View)

```typescript
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import NotificationList from '@/components/notifications/NotificationList';

export default async function NotificationsPage() {
  const session = await getServerSession(authOptions);

  const notifications = await prisma.notification.findMany({
    where: { userId: session.user.id },
    include: {
      task: {
        include: {
          bill: true,
        },
      },
    },
    orderBy: { createdAt: 'desc' },
    take: 50,
  });

  return (
    <div className="container mx-auto p-6">
      <h1 className="text-2xl font-bold mb-6">Notifications</h1>
      <NotificationList notifications={notifications} />
    </div>
  );
}
```

### Add to Layout

**File:** `app/(dashboard)/layout.tsx`

```typescript
import NotificationBell from '@/components/notifications/NotificationBell';

export default function DashboardLayout({ children }) {
  return (
    <div>
      <header className="bg-white shadow">
        <div className="flex items-center justify-between px-6 py-4">
          <h1>Bill Tracker</h1>
          <NotificationBell />
        </div>
      </header>
      <main>{children}</main>
    </div>
  );
}
```

---

## Technical Notes

- **Server Component:** Initial page load fetches notifications server-side
- **Client Component:** Bell and dropdown use client components for interactivity
- **Polling:** Optional 30-second polling for new notifications
- **Pagination:** Limit 20 notifications per page (API supports pagination)
- **Real-time (Future):** Use Server-Sent Events or WebSocket for instant updates

---

## Testing Requirements

### Unit Tests
- [ ] Test GET /api/notifications filters by userId
- [ ] Test PATCH /api/notifications/:id/read updates status
- [ ] Test mark-all-read updates all unread notifications
- [ ] Test unread count calculation

### Integration Tests
- [ ] Test notification list displays all user notifications
- [ ] Test clicking notification marks as read
- [ ] Test clicking notification navigates to task
- [ ] Test mark all read updates all notifications

### E2E Tests
- [ ] Bell shows correct unread count
- [ ] Click bell opens dropdown with notifications
- [ ] Click notification navigates to task detail
- [ ] Mark all read clears badge count
- [ ] Empty state displays when no notifications

---

## Dependencies

**Upstream:**
- Epic 3 US-3.1 & US-3.2: Notifications must be created to display

**Downstream:**
- Epic 4 (Task Actions): Clicking notification navigates to task detail page

**External:**
- None (purely frontend + API)

---

## Definition of Done

- [ ] All acceptance criteria met
- [ ] Notification bell in header
- [ ] Badge shows unread count
- [ ] Dropdown displays notifications
- [ ] Click notification marks as read and navigates
- [ ] Mark all read functional
- [ ] Full page view for all notifications
- [ ] Empty state handled
- [ ] Responsive design
- [ ] Unit tests passing
- [ ] E2E tests passing
- [ ] Code reviewed and merged

---

## UI/UX Design

### Notification Bell
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  [ğŸ””] (5)        â”‚  â† Badge shows unread count
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Dropdown
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Notifications      Mark all read    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ…  Bill added: Internet            â”‚
â”‚     2 hours ago              â—      â”‚ â† Unread indicator
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âš ï¸  Bill due today: Electricity     â”‚
â”‚     5 hours ago                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         View all notifications      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Performance Considerations

- **Pagination:** Load 20 notifications at a time
- **Polling Interval:** 30 seconds (balance between real-time and server load)
- **Caching:** Consider caching unread count query
- **Index:** Database index on `userId` and `readAt` for fast queries

---

## Accessibility

- [ ] Bell icon has aria-label
- [ ] Badge has aria-live for screen readers
- [ ] Keyboard navigation in dropdown
- [ ] Focus management when opening/closing dropdown
- [ ] Semantic HTML for notification items

---

## Future Enhancements

- **Real-time Updates:** Use Server-Sent Events or WebSocket
- **Notification Preferences:** Allow users to mute certain notification types
- **Push Notifications:** Browser push notifications (Web Push API)
- **Grouped Notifications:** Group similar notifications (e.g., "3 bills due today")
- **Notification Actions:** Quick actions from dropdown (mark paid, snooze)

---

## Notes

- **P1 Priority:** Enhances UX but not critical for MVP
- **Polling vs Real-time:** Polling is simpler for MVP, real-time can be added later
- **Design:** Follows standard notification pattern (GitHub, Facebook style)
- **Mobile:** Dropdown should work well on mobile (consider full-page modal)
